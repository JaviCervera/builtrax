Strict

Private
Import vortex
Import tile

Public
Class Grid Final	
	Function Create:Grid(rows:Int[][])
		If CheckRows(rows)
			Return New Grid(rows)
		Else
			Return Null	
		End
	End
	
	Method MoveTile:Bool(tile:Tile)
		Local adjacent:Tile = EmptyAdjacentTile(tile)
		If adjacent <> Null
			Local model:Model = Self.Model(tile)
			mRows[adjacent.Row][adjacent.Column] = model
			mRows[tile.Row][tile.Column] = Null
			model.Position(adjacent.X, 0, adjacent.Y)
			Return True
		Else
			Return False
		End
	End
	
	Method Model:Model(tile:Tile)
		If tile.Row >= 0 And tile.Row < Tile.NumRows And tile.Column >= 0 And tile.Column < Tile.NumColumns
			Return mRows[tile.Row][tile.Column]
		Else
			Return Null
		End
	End
	
	Method TileAt:Tile(entity:Entity)
		Return Tile.FromPoint(entity.WorldX, entity.WorldZ)
	End
Private
	Field mRows:Model[][]
	
	Function CheckRows:Bool(rows:Int[][])
		If rows.Length = Tile.NumRows
			For Local row:Int[] = Eachin rows
				If Not CheckRow(row) Then Return False
			Next
			Return True
		Else
			Return False
		End
	End
	
	Function CheckRow:Bool(row:Int[])
		If row.Length = Tile.NumColumns
			Return True
		Else
			Return False
		End
	End
	
	Method New(rows:Int[][])
		mRows = New Model[0][]
		For Local i:Int = 0 Until rows.Length
			mRows = Append(mRows, ParseRow(rows[i], i))
		Next
	End
	
	Function Append:Model[][](arr:Model[][], row:Model[])
		arr = arr.Resize(arr.Length + 1)
		arr[arr.Length - 1] = row.Resize(row.Length)
		Return arr
	End
	
	Function ParseRow:Model[](row:Int[], rowIndex:Int)
		Local modelRow:Model[] = New Model[row.Length]
		For Local i:Int = 0 Until row.Length
			modelRow[i] = LoadModel(row[i], rowIndex, i)
		Next
		Return modelRow
	End
	
	Function LoadModel:Model(id:Int, rowIndex:Int, colIndex:Int)
		If id <> 0
			Local tile:Tile = New Tile(colIndex, rowIndex)
			Local model:Model = New Model(LoadMesh(id))
			model.Position(tile.X, 0, tile.Y)
			model.Pickable(True)
			Return model
		Else
			Return Null
		End
	End
	
	Function LoadMesh:Mesh(id:Int)
		Local filename:String = "roadTile_" + id + ".msh.dat"
		Local wasLoaded:Bool = Mesh.IsLoaded(filename)
		Local mesh:Mesh = Mesh.Load(filename)
		If Not wasLoaded
			Local max:Float = Max(Max(mesh.Width, mesh.Height), mesh.Depth)
			Local offsetX:Float = (mesh.BoxMaxX - mesh.BoxMinX) / 2
			Local offsetY:Float = (mesh.BoxMaxY - mesh.BoxMinY) / 2
			Local offsetZ:Float = (mesh.BoxMaxZ - mesh.BoxMinZ) / 2
			mesh.Translate(offsetX, offsetY, offsetZ)
			mesh.Scale(1 / max, 1 / max, 1 / max)
		End
		Return mesh
	End
	
	Method EmptyAdjacentTile:Tile(tile:Tile)
		Local left:Tile = New Tile(tile.Column - 1, tile.Row)
		Local right:Tile = New Tile(tile.Column + 1, tile.Row)
		Local up:Tile = New Tile(tile.Column, tile.Row - 1)
		Local down:Tile = New Tile(tile.Column, tile.Row + 1)
		If IsEmptyTile(left)
			Return left
		Elseif IsEmptyTile(right)
			Return right
		Elseif IsEmptyTile(up)
			Return up
		Elseif IsEmptyTile(down)
			Return down
		Else
			Return Null
		End
	End
	
	Method IsEmptyTile:Bool(tile:Tile)
		If tile.Row >= 0 And tile.Row < Tile.NumRows And tile.Column >= 0 And tile.Column < Tile.NumColumns And Self.Model(tile) = Null
			Return True
		Else
			Return False
		End
	End
	
	Method New()
	End
End
