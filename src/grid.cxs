Strict

Private
Import vortex
Import tile

Public
Class Grid Final	
	Function Create:Grid(rows:Int[][])
		InitQuad()
		If CheckRows(rows)
			Return New Grid(rows)
		Else
			Return Null	
		End
	End
	
	Method MoveTile:Bool(tile:Tile)
		Local adjacent:Tile = EmptyAdjacentTile(tile)
		If adjacent <> Null
			Local model:Model = Self.Model(tile)
			mRows[adjacent.Row][adjacent.Column] = model
			mRows[tile.Row][tile.Column] = Null
			model.Position(adjacent.X, 0, adjacent.Y)
			Return True
		Else
			Return False
		End
	End
	
	Method Model:Model(tile:Tile)
		If tile.Row >= 0 And tile.Row < Tile.NumRows And tile.Column >= 0 And tile.Column < Tile.NumColumns
			Return mRows[tile.Row][tile.Column]
		Else
			Return Null
		End
	End
	
	Method TileAt:Tile(entity:Entity)
		Return Tile.FromPoint(entity.WorldX, entity.WorldZ)
	End
Private
	Global mQuad:Mesh
	Field mRows:Model[][]
	
	Function InitQuad:Void()
		If mQuad = Null
			mQuad = Mesh.CreateQuad()
			mQuad.Rotate(90, 0, 0)
			mQuad.Rebuild()
		End
	End
	
	Function CheckRows:Bool(rows:Int[][])
		If rows.Length = Tile.NumRows
			For Local row:Int[] = Eachin rows
				If Not CheckRow(row) Then Return False
			Next
			Return True
		Else
			Return False
		End
	End
	
	Function CheckRow:Bool(row:Int[])
		If row.Length = Tile.NumColumns
			Return True
		Else
			Return False
		End
	End
	
	Method New(rows:Int[][])
		mRows = New Model[0][]
		For Local i:Int = 0 Until rows.Length
			mRows = Append(mRows, ParseRow(rows[i], i))
		Next
	End
	
	Function Append:Model[][](arr:Model[][], row:Model[])
		arr = arr.Resize(arr.Length + 1)
		arr[arr.Length - 1] = row.Resize(row.Length)
		Return arr
	End
	
	Function ParseRow:Model[](row:Int[], rowIndex:Int)
		Local modelRow:Model[] = New Model[row.Length]
		For Local i:Int = 0 Until row.Length
			modelRow[i] = LoadModel(row[i], rowIndex, i)
		Next
		Return modelRow
	End
	
	Function LoadModel:Model(id:Int, rowIndex:Int, colIndex:Int)
		If id <> 0
			Local tile:Tile = New Tile(colIndex, rowIndex)
			Local model:Model = New Model(mQuad)
			model.Material(0).ColorTexture = Texture.Load(LPad(id, "0", 2) + ".png", Texture.FilterNone)
			model.Position(tile.X, 0, tile.Y)
			model.Pickable(True)
			Return model
		Else
			Return Null
		End
	End
	
	Function LPad:String(str:String, char:String, len:Int)
		char = char[0..1]
		Local amount:Int = Max(0, len - str.Length)
		Local lpad:String = ""
		For Local i:Int = 0 Until amount
			lpad += char
		Next
		Return lpad + str
	End
	
	Method EmptyAdjacentTile:Tile(tile:Tile)
		Local left:Tile = New Tile(tile.Column - 1, tile.Row)
		Local right:Tile = New Tile(tile.Column + 1, tile.Row)
		Local up:Tile = New Tile(tile.Column, tile.Row - 1)
		Local down:Tile = New Tile(tile.Column, tile.Row + 1)
		If IsEmptyTile(left)
			Return left
		Elseif IsEmptyTile(right)
			Return right
		Elseif IsEmptyTile(up)
			Return up
		Elseif IsEmptyTile(down)
			Return down
		Else
			Return Null
		End
	End
	
	Method IsEmptyTile:Bool(tile:Tile)
		If tile.Row >= 0 And tile.Row < Tile.NumRows And tile.Column >= 0 And tile.Column < Tile.NumColumns And Self.Model(tile) = Null
			Return True
		Else
			Return False
		End
	End
	
	Method New()
	End
End
